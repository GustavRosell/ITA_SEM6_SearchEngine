@page "/search"
@page "/"
@using System.Net.Http.Json
@using System.Text.Json
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<PageTitle>Search Engine</PageTitle>

<div class="container">
    <h1>Search Engine</h1>

    <div class="row mb-4">
        <div class="col-md-8">
            <div class="input-group">
                <input type="text" @bind="searchQuery" @onkeypress="HandleKeyPress" class="form-control" placeholder="Enter search terms..." />
                <button class="btn btn-primary" @onclick="PerformSearch" disabled="@isLoading">
                    @if (isLoading)
                    {
                        <span class="spinner-border spinner-border-sm me-2"></span>
                    }
                    Search
                </button>
            </div>
        </div>
        <div class="col-md-4">
            <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" @bind="patternSearch" id="patternSearchSwitch">
                <label class="form-check-label" for="patternSearchSwitch">
                    Pattern Search (use * and ?)
                </label>
            </div>
        </div>
    </div>

    <div class="row mb-3">
        <div class="col-md-12">
            <div class="d-flex gap-3">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" @bind="caseSensitive" id="caseSensitiveSwitch">
                    <label class="form-check-label" for="caseSensitiveSwitch">Case Sensitive</label>
                </div>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" @bind="includeTimestamps" id="timestampSwitch">
                    <label class="form-check-label" for="timestampSwitch">Show Timestamps</label>
                </div>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" @bind="compactView" id="compactViewSwitch">
                    <label class="form-check-label" for="compactViewSwitch">Compact View</label>
                </div>
                <div class="input-group" style="width: 200px;">
                    <span class="input-group-text">Limit</span>
                    <input type="number" @bind="resultLimit" class="form-control" min="1" max="1000" />
                </div>
            </div>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger">
            @errorMessage
        </div>
    }

    @* Reworked results rendering: pattern search and normal search have independent conditions *@
    @if (patternSearch)
    {
        <div class="results-section">
            <h3>Pattern Search Results</h3>
            @if (isLoading)
            {
                <p><em>Searching...</em></p>
            }
            else if (patternResults != null && patternResults.Any())
            {
                <p>
                    @if (patternMeta != null)
                    {
                        if (patternMeta.TotalDocuments == 0)
                        {
                            <text>No documents matched pattern "@lastSearchQuery"</text>
                        }
                        else if (patternMeta.IsTruncated)
                        {
                            <text>Found @patternMeta.TotalDocuments documents and @patternMeta.TotalHits hits (showing @patternMeta.ReturnedDocuments documents / @patternMeta.ReturnedHits hits due to limit) for pattern "@lastSearchQuery" in @patternMeta.TimeUsed.ToString("F2") ms</text>
                        }
                        else
                        {
                            <text>Found @patternMeta.ReturnedDocuments documents and @patternMeta.ReturnedHits hits for pattern "@lastSearchQuery" in @patternMeta.TimeUsed.ToString("F2") ms</text>
                        }
                    }
                    else
                    {
                        var fallbackDocCount = patternResults.Count;
                        // Approximate hits locally: distinct matching words per document summed (same logic as backend ordering metric)
                        var fallbackHitCount = patternResults.Sum(r => r.MatchingWords.Distinct(StringComparer.OrdinalIgnoreCase).Count());
                        <text>Found @fallbackDocCount documents and @fallbackHitCount hits matching pattern "@lastSearchQuery"</text>
                    }
                </p>
                <div class="list-group">
                    @foreach (var (result, index) in patternResults.Select((r, i) => (r, i + 1)))
                    {
                        @if (compactView)
                        {
                            <div class="list-group-item py-2">
                                @{
                                    var fileName = System.IO.Path.GetFileName(result.Document.Url);
                                    var matchText = result.MatchingWords.Count == 1 ? "match" : "matches";
                                }
                                <span>@index. @fileName (@result.MatchingWords.Count @matchText): @string.Join(", ", result.MatchingWords)</span>
                            </div>
                        }
                        else
                        {
                            <div class="list-group-item">
                                <div class="d-flex w-100 justify-content-between">
                                    <h5 class="mb-1">@index. @System.IO.Path.GetFileName(result.Document.Url)</h5>
                                    <small>@result.MatchingWords.Count match(es)</small>
                                </div>
                                <p class="mb-1">
                                    <strong>File:</strong> @result.Document.Url<br />
                                    <strong>Matching terms:</strong> @string.Join(", ", result.MatchingWords)
                                </p>
                                @if (includeTimestamps && !string.IsNullOrEmpty(result.Document.IndexTime))
                                {
                                    <small>Indexed: @result.Document.IndexTime</small>
                                }
                            </div>
                        }
                    }
                </div>
            }
            else if (!isLoading && patternResults != null && !patternResults.Any())
            {
                <div class="alert alert-info">No documents matched the pattern "@lastSearchQuery".</div>
            }
        </div>
    }
    else if (searchResults != null)
    {
        <div class="results-section">
            <h3>Search Results</h3>
            <p>
                @if (searchResults.IsTruncated)
                {
                    <text>Found @searchResults.TotalDocuments documents and @searchResults.TotalHits hits (showing @searchResults.ReturnedDocuments documents / @searchResults.ReturnedHits hits due to limit) in @searchResults.TimeUsed.ToString("F2") ms</text>
                }
                else
                {
                    <text>Found @searchResults.ReturnedDocuments documents and @searchResults.ReturnedHits hits in @searchResults.TimeUsed.ToString("F2") ms</text>
                }
            </p>
            @if (searchResults.Ignored?.Any() == true)
            {
                <div class="alert alert-warning">
                    <strong>Ignored terms:</strong> @string.Join(", ", searchResults.Ignored)
                </div>
            }
            @if (searchResults.DocumentHits?.Any() == true)
            {
                <div class="list-group">
                    @foreach (var (result, index) in searchResults.DocumentHits.Select((r, i) => (r, i + 1)))
                    {
                        @if (compactView)
                        {
                            <div class="list-group-item py-2">
                                @{
                                    var fileName = System.IO.Path.GetFileName(result.Document.Url);
                                    var hitText = result.NoOfHits == 1 ? "match" : "matches";
                                    var allTerms = searchResults.Query.ToList();
                                    var matchingTerms = allTerms.Except(result.Missing ?? new List<string>()).ToArray();
                                }
                                <span>@index. @fileName (@result.NoOfHits @hitText): @string.Join(", ", matchingTerms)</span>
                            </div>
                        }
                        else
                        {
                            <div class="list-group-item">
                                <div class="d-flex w-100 justify-content-between">
                                    <h5 class="mb-1">@index. @System.IO.Path.GetFileName(result.Document.Url)</h5>
                                    <small>@result.NoOfHits hit(s)</small>
                                </div>
                                <p class="mb-1"><strong>File:</strong> @result.Document.Url</p>
                                @if (includeTimestamps && !string.IsNullOrEmpty(result.Document.IndexTime))
                                {
                                    <small>Indexed: @result.Document.IndexTime</small>
                                }
                                @if (result.Missing?.Any() == true)
                                {
                                    <small class="text-muted d-block">Missing terms: @string.Join(", ", result.Missing)</small>
                                }
                            </div>
                        }
                    }
                </div>
            }
            else
            {
                <div class="alert alert-info">No documents found matching your search terms.</div>
            }
        </div>
    }
</div>

@code {
    private string searchQuery = "";
    private bool isLoading = false;
    private string errorMessage = "";
    private string lastSearchQuery = "";
    
    // Search options
    private bool caseSensitive = false;
    private bool includeTimestamps = true;
    private int resultLimit = 20;
    private bool patternSearch = false;
    private bool compactView = false;

    // Results
    private SearchResult? searchResults = null;
    private List<PatternResult>? patternResults = null;
        private PatternMeta? patternMeta = null;

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await PerformSearch();
        }
    }

    private async Task PerformSearch()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
            return;

        isLoading = true;
        errorMessage = "";
        lastSearchQuery = searchQuery.Trim();
        
        try
        {
            var baseUrl = "http://localhost:5137/api/search";
            
            if (patternSearch)
            {
                var patternUrl = $"{baseUrl}/pattern?pattern={lastSearchQuery}&caseSensitive={caseSensitive}&limit={resultLimit}";
                Console.WriteLine($"DEBUG PATTERN: searchQuery='{searchQuery}', lastSearchQuery='{lastSearchQuery}', patternUrl='{patternUrl}'");
                var patternResponse = await Http.GetAsync(patternUrl);
                
                if (patternResponse.IsSuccessStatusCode)
                {
                    var json = await patternResponse.Content.ReadAsStringAsync();
                    Console.WriteLine($"BLAZOR DEBUG: Pattern response JSON: {json}");
                    
                    var apiResponse = JsonSerializer.Deserialize<PatternSearchResponse>(json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    Console.WriteLine($"BLAZOR DEBUG: Deserialized response - Hits count: {apiResponse?.Hits?.Count ?? 0}");
                    
                    patternResults = apiResponse?.Hits?.Select(hit => new PatternResult
                    {
                        Document = new DocumentInfo
                        {
                            Id = hit.Document.Id,
                            Url = hit.Document.Url,
                            IndexTime = hit.Document.IndexTime,
                            CreationTime = hit.Document.CreationTime
                        },
                        MatchingWords = hit.MatchingWords
                    }).ToList() ?? new List<PatternResult>();
                        if (apiResponse != null)
                        {
                            patternMeta = new PatternMeta { TotalDocuments = apiResponse.TotalDocuments, ReturnedDocuments = apiResponse.ReturnedDocuments, TotalHits = apiResponse.TotalHits, ReturnedHits = apiResponse.ReturnedHits, IsTruncated = apiResponse.IsTruncated, TimeUsed = apiResponse.TimeUsed };
                        }
                        else
                        {
                            patternMeta = null;
                        }
                    
                    Console.WriteLine($"BLAZOR DEBUG: Final patternResults count: {patternResults.Count}");
                    searchResults = null;
                    StateHasChanged(); // Force UI update
                }
                else
                {
                    errorMessage = $"Search failed: {patternResponse.StatusCode}";
                }
            }
            else
            {
                var searchUrl = $"{baseUrl}?query={Uri.EscapeDataString(lastSearchQuery)}&caseSensitive={caseSensitive}&limit={resultLimit}&includeTimestamps={includeTimestamps}";
                var response = await Http.GetAsync(searchUrl);
                
                if (response.IsSuccessStatusCode)
                {
                    var json = await response.Content.ReadAsStringAsync();
                    var apiResponse = JsonSerializer.Deserialize<ApiSearchResponse>(json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    
                    searchResults = new SearchResult
                    {
                        Query = apiResponse?.Query ?? Array.Empty<string>(),
                        TotalDocuments = apiResponse?.TotalDocuments ?? 0,
                        ReturnedDocuments = apiResponse?.ReturnedDocuments ?? 0,
                        IsTruncated = apiResponse?.IsTruncated ?? false,
                        TotalHits = apiResponse?.TotalHits ?? 0,
                        ReturnedHits = apiResponse?.ReturnedHits ?? 0,
                        DocumentHits = apiResponse?.DocumentHits?.Select(hit => new DocumentHit
                        {
                            Document = new DocumentInfo
                            {
                                Id = hit.Document.Id,
                                Url = hit.Document.Url,
                                IndexTime = hit.Document.IndexTime,
                                CreationTime = hit.Document.CreationTime
                            },
                            NoOfHits = hit.NoOfHits,
                            Missing = hit.Missing
                        }).ToList() ?? new List<DocumentHit>(),
                        Ignored = apiResponse?.Ignored ?? new List<string>(),
                        TimeUsed = apiResponse?.TimeUsed ?? 0
                    };
                    
                    patternResults = null;
                              patternMeta = null;
                }
                else
                {
                    errorMessage = $"Search failed: {response.StatusCode}";
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"BLAZOR DEBUG: Exception occurred: {ex.Message}");
            Console.WriteLine($"BLAZOR DEBUG: Stack trace: {ex.StackTrace}");
            errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    // Data models for Blazor
    public class SearchResult
    {
        public string[] Query { get; set; } = Array.Empty<string>();
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public List<DocumentHit> DocumentHits { get; set; } = new();
        public List<string> Ignored { get; set; } = new();
        public double TimeUsed { get; set; }
    }

    public class DocumentHit
    {
        public DocumentInfo Document { get; set; } = new();
        public int NoOfHits { get; set; }
        public List<string> Missing { get; set; } = new();
    }

    public class PatternResult
    {
        public DocumentInfo Document { get; set; } = new();
        public List<string> MatchingWords { get; set; } = new();
    }

    public class DocumentInfo
    {
        public int Id { get; set; }
        public string Url { get; set; } = "";
        public string IndexTime { get; set; } = "";
        public string CreationTime { get; set; } = "";
    }

    // API response models
    public class ApiSearchResponse
    {
        public string[] Query { get; set; } = Array.Empty<string>();
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public List<ApiDocumentHit> DocumentHits { get; set; } = new();
        public List<string> Ignored { get; set; } = new();
        public double TimeUsed { get; set; }
    }

    public class ApiDocumentHit
    {
        public ApiDocument Document { get; set; } = new();
        public int NoOfHits { get; set; }
        public List<string> Missing { get; set; } = new();
    }

    public class PatternSearchResponse
    {
        public string Pattern { get; set; } = "";
        public List<PatternHit> Hits { get; set; } = new();
        // Added metadata fields from API
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public double TimeUsed { get; set; }
    }

    public class PatternMeta
    {
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public double TimeUsed { get; set; }
    }

    public class PatternHit
    {
        public ApiDocument Document { get; set; } = new();
        public List<string> MatchingWords { get; set; } = new();
    }

    public class ApiDocument
    {
        public int Id { get; set; }
        public string Url { get; set; } = "";
        public string IndexTime { get; set; } = "";
        public string CreationTime { get; set; } = "";
    }
}