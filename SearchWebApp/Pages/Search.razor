@page "/search"
@using System.Net.Http.Json
@using System.Text.Json
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject IConfiguration Configuration

<!-- Deployment Mode Watermark (Z-Scale or X-Scale Visualization) -->
@if (isZScaleMode)
{
    <div class="instance-watermark mode-z-scale">
        <span class="watermark-label">Mode:</span>
        <span class="watermark-id">Z-Scale (3 partitions)</span>
    </div>
}
else if (!string.IsNullOrEmpty(currentInstanceId))
{
    <div class="instance-watermark">
        <span class="watermark-label">Instance:</span>
        <span class="watermark-id">@currentInstanceId</span>
    </div>
}

<div class="content-wrapper">
    <!-- Search Section -->
    <div class="search-section">
        <h2 class="search-title">What would you like to search for?</h2>
        
        <!-- Search Input -->
        <div class="search-input-container">
            <span class="icon icon-search search-icon"></span>
            <input type="text" 
                   @bind="searchQuery" 
                   @onkeyup="HandleKeyPress" 
                   class="search-input" 
                   placeholder="Search documents..." />
            <button type="button" 
                    class="search-button" 
                    @onclick="PerformSearch" 
                    disabled="@isLoading">
                @if (isLoading)
                {
                    <div class="icon-spinner"></div>
                }
                Search
            </button>
        </div>

        <!-- Filter Buttons -->
        <div class="filter-buttons">
            <button type="button" 
                    class="filter-button @(caseSensitive ? "active" : "")"
                    @onclick="() => caseSensitive = !caseSensitive">
                <span class="icon icon-hash icon-sm"></span>
                Case Sensitive
            </button>
            
            <button type="button" 
                    class="filter-button @(patternSearch ? "active" : "")"
                    @onclick="() => patternSearch = !patternSearch">
                <span class="icon icon-pattern icon-sm"></span>
                Pattern Search
            </button>
            
            <button type="button" 
                    class="filter-button @(compactView ? "active" : "")"
                    @onclick="() => compactView = !compactView">
                <span class="icon icon-eye icon-sm"></span>
                Compact View
            </button>
            
            <button type="button" 
                    class="filter-button @(includeTimestamps ? "active" : "")"
                    @onclick="() => includeTimestamps = !includeTimestamps">
                <span class="icon icon-calendar icon-sm"></span>
                Timestamps
            </button>
        </div>

        <!-- Result Limit -->
        <div class="result-limit-section">
            <span class="icon icon-settings"></span>
            <span>Results:</span>
            
            <div class="select-container">
                <select @bind="resultLimitOption" @bind:after="OnResultLimitChanged" class="select">
                    <option value="20">20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="150">150</option>
                    <option value="200">200</option>
                    <option value="custom">Custom</option>
                </select>
            </div>

            @if (resultLimitOption == "custom")
            {
                <input type="number" 
                       @bind="customLimit" 
                       @bind:after="OnCustomLimitChanged"
                       class="custom-input" 
                       placeholder="Enter limit" 
                       min="1" 
                       max="1000" />
            }
        </div>
    </div>

    <!-- Error Message -->
    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="card" style="border-color: var(--destructive);">
            <div class="card-content" style="color: var(--destructive);">
                @errorMessage
            </div>
        </div>
    }

    <!-- Results -->
    @if (!string.IsNullOrWhiteSpace(searchQuery))
    {
        <div class="results-section">
            <!-- Loading State -->
            @if (isLoading)
            {
                <div class="loading">
                    <div class="icon-spinner"></div>
                    Searching...
                </div>
            }
            else
            {
                <!-- Pattern Search Results -->
                @if (patternSearch && patternResults != null)
                {
                    <!-- Results Header -->
                    <div class="results-header">
                        <div class="results-count">
                            @if (patternMeta != null)
                            {
                                if (patternMeta.TotalDocuments == 0)
                                {
                                    <text>No documents matched pattern "@lastSearchQuery"</text>
                                }
                                else if (patternMeta.IsTruncated)
                                {
                                    <text>@patternMeta.ReturnedDocuments of @patternMeta.TotalDocuments documents for "@lastSearchQuery" (@patternMeta.TimeUsed.ToString("F1")ms)</text>
                                }
                                else
                                {
                                    <text>@patternMeta.ReturnedDocuments documents for "@lastSearchQuery" (@patternMeta.TimeUsed.ToString("F1")ms)</text>
                                }
                            }
                            else
                            {
                                <text>@patternResults.Count results for "@lastSearchQuery"</text>
                            }
                        </div>
                    </div>

                    <!-- Pattern Results List -->
                    <div class="results-list">
                        @foreach (var (result, index) in patternResults.Select((r, i) => (r, i + 1)))
                        {
                            <div class="card">
                                <div class="card-header @(compactView ? "compact clickable" : "")" @onclick="@(() => HandleCardClick(compactView, $"pattern_{result.Document.Id}_{index}"))">
                                    <div class="card-title-row">
                                        <h3 class="card-title">@index. @System.IO.Path.GetFileName(result.Document.Url)</h3>
                                        <div class="card-meta">
                                            <span class="badge">@result.MatchingWords.Count match@(result.MatchingWords.Count == 1 ? "" : "es")</span>
                                            @if (compactView)
                                            {
                                                <span class="expand-icon">@(IsExpanded($"pattern_{result.Document.Id}_{index}") ? "▼" : "▶")</span>
                                            }
                                        </div>
                                    </div>
                                </div>
                                
                                @if (!compactView || IsExpanded($"pattern_{result.Document.Id}_{index}"))
                                {
                                    <div class="card-content">
                                        <div class="card-text">
                                            <strong>File:</strong> @result.Document.Url<br />
                                            <strong>Matching terms:</strong> @string.Join(", ", result.MatchingWords)
                                        </div>
                                        @if (includeTimestamps && !string.IsNullOrEmpty(result.Document.IndexTime))
                                        {
                                            <div class="card-timestamp">
                                                Indexed: @DateTime.Parse(result.Document.IndexTime).ToString("MMM d, yyyy 'at' HH:mm")
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    </div>
                }
                <!-- Normal Search Results -->
                else if (!patternSearch && searchResults != null)
                {
                    <!-- Results Header -->
                    <div class="results-header">
                        <div class="results-count">
                            @if (searchResults.IsTruncated)
                            {
                                <text>@searchResults.ReturnedDocuments of @searchResults.TotalDocuments documents for "@string.Join(" ", searchResults.Query)" (@searchResults.TimeUsed.ToString("F1")ms)</text>
                            }
                            else
                            {
                                <text>@searchResults.ReturnedDocuments documents for "@string.Join(" ", searchResults.Query)" (@searchResults.TimeUsed.ToString("F1")ms)</text>
                            }
                        </div>
                    </div>

                    <!-- Ignored Terms -->
                    @if (searchResults.Ignored?.Any() == true)
                    {
                        <div class="card" style="border-color: rgba(234, 88, 12, 0.3); background-color: rgba(234, 88, 12, 0.05);">
                            <div class="card-content">
                                <strong>Ignored terms:</strong> @string.Join(", ", searchResults.Ignored)
                            </div>
                        </div>
                    }

                    <!-- Normal Results List -->
                    <div class="results-list">
                        @foreach (var (result, index) in searchResults.DocumentHits.Select((r, i) => (r, i + 1)))
                        {
                            <div class="card">
                                <div class="card-header @(compactView ? "compact clickable" : "")" @onclick="@(() => HandleCardClick(compactView, $"normal_{result.Document.Id}_{index}"))">
                                    <div class="card-title-row">
                                        <h3 class="card-title">@index. @System.IO.Path.GetFileName(result.Document.Url)</h3>
                                        <div class="card-meta">
                                            <span class="badge">@result.NoOfHits hit@(result.NoOfHits == 1 ? "" : "s")</span>
                                            @if (compactView)
                                            {
                                                <span class="expand-icon">@(IsExpanded($"normal_{result.Document.Id}_{index}") ? "▼" : "▶")</span>
                                            }
                                        </div>
                                    </div>
                                </div>
                                
                                @if (!compactView || IsExpanded($"normal_{result.Document.Id}_{index}"))
                                {
                                    <div class="card-content">
                                        <div class="card-text">
                                            <strong>File:</strong> @result.Document.Url
                                        </div>
                                        @if (includeTimestamps && !string.IsNullOrEmpty(result.Document.IndexTime))
                                        {
                                            <div class="card-timestamp">
                                                Indexed: @DateTime.Parse(result.Document.IndexTime).ToString("MMM d, yyyy 'at' HH:mm")
                                            </div>
                                        }
                                        @if (result.Missing?.Any() == true)
                                        {
                                            <div class="card-timestamp">
                                                Missing terms: @string.Join(", ", result.Missing)
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }
                    </div>
                }
                <!-- Empty State -->
                else
                {
                    <div class="empty-state">
                        <div class="icon icon-search empty-icon"></div>
                        <div class="empty-title">No results found</div>
                        <div class="empty-description">Try adjusting your search terms or filters</div>
                    </div>
                }
            }
        </div>
    }
</div>

@code {
    // Search state
    private string searchQuery = "";
    private bool isLoading = false;
    private string errorMessage = "";
    private string lastSearchQuery = "";
    private string currentInstanceId = "";
    private bool isZScaleMode = false;

    // Search options
    private bool caseSensitive = false;
    private bool includeTimestamps = true;
    private bool patternSearch = false;
    private bool compactView = false;

    // Expandable items tracking
    private Dictionary<string, bool> expandedItems = new();

    // Result limit
    private string resultLimitOption = "20";
    private int customLimit = 50;

    private int ResultLimit => resultLimitOption == "custom" ? customLimit : int.Parse(resultLimitOption);

    // Results
    private SearchResult? searchResults = null;
    private List<PatternResult>? patternResults = null;
    private PatternMeta? patternMeta = null;

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await PerformSearch();
        }
    }

    private async Task PerformSearch()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
            return;

        isLoading = true;
        errorMessage = "";
        lastSearchQuery = searchQuery.Trim();
        
        try
        {
            // Read API base URL from configuration
            // Default: http://localhost:8080 (load balancer)
            // Can be overridden in appsettings.json: "ApiSettings:BaseUrl"
            var apiBaseUrl = Configuration["ApiSettings:BaseUrl"] ?? "http://localhost:8080";
            var baseUrl = $"{apiBaseUrl}/api/search";
            
            if (patternSearch)
            {
                var patternUrl = $"{baseUrl}/pattern?pattern={Uri.EscapeDataString(lastSearchQuery)}&caseSensitive={caseSensitive}&limit={ResultLimit}";
                var patternResponse = await Http.GetAsync(patternUrl);
                
                if (patternResponse.IsSuccessStatusCode)
                {
                    var json = await patternResponse.Content.ReadAsStringAsync();
                    var apiResponse = JsonSerializer.Deserialize<PatternSearchResponse>(json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                    // Detect deployment mode: Z-Scale (Coordinator) vs X-Scale/Single (SearchAPI)
                    currentInstanceId = apiResponse?.InstanceId ?? "";
                    isZScaleMode = string.IsNullOrEmpty(currentInstanceId);

                    patternResults = apiResponse?.Hits?.Select(hit => new PatternResult
                    {
                        Document = new DocumentInfo
                        {
                            Id = hit.Document.Id,
                            Url = hit.Document.Url,
                            IndexTime = hit.Document.IndexTime,
                            CreationTime = hit.Document.CreationTime
                        },
                        MatchingWords = hit.MatchingWords
                    }).ToList() ?? new List<PatternResult>();
                    
                    if (apiResponse != null)
                    {
                        patternMeta = new PatternMeta { 
                            TotalDocuments = apiResponse.TotalDocuments, 
                            ReturnedDocuments = apiResponse.ReturnedDocuments, 
                            TotalHits = apiResponse.TotalHits, 
                            ReturnedHits = apiResponse.ReturnedHits, 
                            IsTruncated = apiResponse.IsTruncated, 
                            TimeUsed = apiResponse.TimeUsed 
                        };
                    }
                    else
                    {
                        patternMeta = null;
                    }
                    
                    searchResults = null;
                    StateHasChanged();
                }
                else
                {
                    errorMessage = $"Search failed: {patternResponse.StatusCode}";
                }
            }
            else
            {
                var searchUrl = $"{baseUrl}?query={Uri.EscapeDataString(lastSearchQuery)}&caseSensitive={caseSensitive}&limit={ResultLimit}&includeTimestamps={includeTimestamps}";
                var response = await Http.GetAsync(searchUrl);
                
                if (response.IsSuccessStatusCode)
                {
                    var json = await response.Content.ReadAsStringAsync();
                    var apiResponse = JsonSerializer.Deserialize<ApiSearchResponse>(json, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                    // Detect deployment mode: Z-Scale (Coordinator) vs X-Scale/Single (SearchAPI)
                    currentInstanceId = apiResponse?.InstanceId ?? "";
                    isZScaleMode = string.IsNullOrEmpty(currentInstanceId);

                    searchResults = new SearchResult
                    {
                        Query = apiResponse?.Query ?? Array.Empty<string>(),
                        TotalDocuments = apiResponse?.TotalDocuments ?? 0,
                        ReturnedDocuments = apiResponse?.ReturnedDocuments ?? 0,
                        IsTruncated = apiResponse?.IsTruncated ?? false,
                        TotalHits = apiResponse?.TotalHits ?? 0,
                        ReturnedHits = apiResponse?.ReturnedHits ?? 0,
                        DocumentHits = apiResponse?.DocumentHits?.Select(hit => new DocumentHit
                        {
                            Document = new DocumentInfo
                            {
                                Id = hit.Document.Id,
                                Url = hit.Document.Url,
                                IndexTime = hit.Document.IndexTime,
                                CreationTime = hit.Document.CreationTime
                            },
                            NoOfHits = hit.NoOfHits,
                            Missing = hit.Missing
                        }).ToList() ?? new List<DocumentHit>(),
                        Ignored = apiResponse?.Ignored ?? new List<string>(),
                        TimeUsed = apiResponse?.TimeUsed ?? 0
                    };
                    
                    patternResults = null;
                    patternMeta = null;
                }
                else
                {
                    errorMessage = $"Search failed: {response.StatusCode}";
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    // Expandable items functionality
    private void ToggleExpanded(string key)
    {
        if (expandedItems.ContainsKey(key))
        {
            expandedItems[key] = !expandedItems[key];
        }
        else
        {
            expandedItems[key] = true;
        }
    }
    
    private bool IsExpanded(string key)
    {
        return expandedItems.TryGetValue(key, out var isExpanded) && isExpanded;
    }

    // Auto-update search when result limits change
    private async Task OnResultLimitChanged()
    {
        // Only re-search if we already have results (avoid empty searches)
        if (!string.IsNullOrWhiteSpace(lastSearchQuery))
        {
            await PerformSearch();
        }
    }

    private async Task OnCustomLimitChanged()
    {
        // Only re-search if custom option is selected and we have results
        if (resultLimitOption == "custom" && !string.IsNullOrWhiteSpace(lastSearchQuery))
        {
            await PerformSearch();
        }
    }

    // Helper method to handle card clicks without null warnings
    private void HandleCardClick(bool isCompactView, string key)
    {
        if (isCompactView)
        {
            ToggleExpanded(key);
        }
    }

    // Data models for Blazor (same as original)
    public class SearchResult
    {
        public string[] Query { get; set; } = Array.Empty<string>();
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public List<DocumentHit> DocumentHits { get; set; } = new();
        public List<string> Ignored { get; set; } = new();
        public double TimeUsed { get; set; }
    }

    public class DocumentHit
    {
        public DocumentInfo Document { get; set; } = new();
        public int NoOfHits { get; set; }
        public List<string> Missing { get; set; } = new();
    }

    public class PatternResult
    {
        public DocumentInfo Document { get; set; } = new();
        public List<string> MatchingWords { get; set; } = new();
    }

    public class DocumentInfo
    {
        public int Id { get; set; }
        public string Url { get; set; } = "";
        public string IndexTime { get; set; } = "";
        public string CreationTime { get; set; } = "";
    }

    // API response models (same as original)
    public class ApiSearchResponse
    {
        public string InstanceId { get; set; } = "";
        public string[] Query { get; set; } = Array.Empty<string>();
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public List<ApiDocumentHit> DocumentHits { get; set; } = new();
        public List<string> Ignored { get; set; } = new();
        public double TimeUsed { get; set; }
    }

    public class ApiDocumentHit
    {
        public ApiDocument Document { get; set; } = new();
        public int NoOfHits { get; set; }
        public List<string> Missing { get; set; } = new();
    }

    public class PatternSearchResponse
    {
        public string InstanceId { get; set; } = "";
        public string Pattern { get; set; } = "";
        public List<PatternHit> Hits { get; set; } = new();
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public double TimeUsed { get; set; }
    }

    public class PatternMeta
    {
        public int TotalDocuments { get; set; }
        public int ReturnedDocuments { get; set; }
        public bool IsTruncated { get; set; }
        public int TotalHits { get; set; }
        public int ReturnedHits { get; set; }
        public double TimeUsed { get; set; }
    }

    public class PatternHit
    {
        public ApiDocument Document { get; set; } = new();
        public List<string> MatchingWords { get; set; } = new();
    }

    public class ApiDocument
    {
        public int Id { get; set; }
        public string Url { get; set; } = "";
        public string IndexTime { get; set; } = "";
        public string CreationTime { get; set; } = "";
    }
}