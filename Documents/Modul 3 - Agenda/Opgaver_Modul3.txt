# Opgaver Modul 3 - AKF Scale Cube
## IT-Arkitektur Semester 6, Erhvervsakademiet Aarhus

---

## Opgave 1: Webshop Skalering

**Forestil jer en webshop, hvor indkøbskurven (som er tilstand) – ligger på web-serveren. Webshoppen performer dårligt og man tænker på at x-skalere webshoppen.**

### Problemer:
- **Session Affinity Problem**: Når indkøbskurven ligger på web-serveren, skal brugeren altid ramme samme server-instans. Dette eliminerer fordelene ved X-akse skalering.
- **Load Balancer Kompleksitet**: Kræver "sticky sessions" eller session affinity, hvilket komplicerer load balancing og kan skabe ubalance.
- **Single Point of Failure**: Hvis en server går ned, mister brugerne deres indkøbskurve.
- **Ineffektiv Resource Udnyttelse**: Nogle servere kan være overbelastede mens andre står ledige, fordi brugere er "bundet" til specifikke servere.

### Løsninger:
1. **Eksternalisér Session State** (X-akse forbedring):
   - Flyt indkøbskurven til ekstern storage (Redis, database)
   - Gør alle web-servere stateless
   - Muliggør ægte load balancing mellem identiske instanser

2. **Database/Cache Skalering**:
   - Implementér distributed cache (Redis Cluster)
   - Database replication for session storage

3. **Forberedelse til Y-akse**:
   - Overvej at separere indkøbskurv-funktionalitet som egen microservice
   - Shopping Cart API som separat komponent

---

## Opgave 2: Billetnet.dk Skalering

**Billetnet.dk sælger billetter til større arrangementer. Salget er meget stort i peaks – som er forudsigelige. Fx 20.000 solgte billetter på bare 20 min., med op til 30.000 besøgende. Udenfor peaks er der ikke mange besøgende/salg.**

### Skalerings-strategier afhængig af bottleneck:

#### Hvis problemet er i Web-serveren (Præsentation):
**X-akse skalering:**
- Auto-scaling af web-server instanser
- Load balancer foran multiple web-servere
- CDN for statisk content (billeder, CSS, JS)
- Horizontal scaling under peaks

#### Hvis problemet er i Application-serveren (API):
**X-akse skalering:**
- Multiple API instanser med load balancing
- Container orchestration (Kubernetes) for auto-scaling

**Y-akse skalering:**
- Separer funktioner i microservices:
  - Ticket Search Service
  - Payment Processing Service
  - User Management Service
  - Event Management Service
- Queue-baseret arkitektur for ticket reservationer

#### Hvis problemet er i Databasen:
**X-akse database skalering:**
- Read replicas for søgninger
- Write scaling gennem clustering

**Z-akse database skalering:**
- Partitionering efter arrangement/event
- Geografisk distribution af data

#### Kombineret Strategi (Anbefalet):
1. **X-akse**: Auto-scaling af alle lag under peaks
2. **Y-akse**: Microservices for kritiske funktioner
3. **Z-akse**: Event-baseret partitionering
4. **Queue System**: Async processing af payments
5. **Caching**: Redis for populære events og user sessions

---

## Opgave 3: Y-skalering af ConsoleSearch

**Vi skal have y-skaleret ConsoleSearch, så den opdeles i to komponenter: en konsol applikation som varetager interaktion med brugeren (og kun dette) og et API som indeholder søgelogikken.**

### Arkitektur Design:

#### Komponent 1: Console Client
**Ansvar:** Kun brugerinteraktion
- Menu-system og bruger input
- Formatering og visning af resultater
- Configuration management (lokalt)
- HTTP client til API kommunikation

**Implementering:**
```
ConsoleSearch/
├── Program.cs          (Entry point)
├── ConsoleApp.cs       (UI logic, menu system)
├── ApiClient.cs        (HTTP kommunikation)
├── ResultFormatter.cs  (Display logic)
└── Config.cs          (UI preferences)
```

#### Komponent 2: Search API
**Ansvar:** Søgelogik og data access
- SearchLogic klassen flyttes hertil
- Database adgang
- Search algoritme og ranking
- RESTful endpoints

**Implementering:**
```
SearchAPI/
├── Program.cs              (Web API startup)
├── Controllers/
│   └── SearchController.cs (REST endpoints)
├── Services/
│   └── SearchService.cs    (SearchLogic klasse flyttet)
├── Models/
│   ├── SearchRequest.cs
│   └── SearchResponse.cs
└── Data/
    └── DatabaseSqlite.cs   (Data access)
```

#### API Endpoints:
```
GET /api/search?query={query}&limit={limit}&caseSensitive={bool}&pattern={bool}
POST /api/search (for komplekse queries)
GET /api/health
```

#### Kommunikation:
- Console app sender HTTP requests til API
- JSON serialization af requests/responses
- Error handling og timeout management

### Fordele ved Y-akse split:
- **Separation of Concerns**: UI og business logic adskilt
- **Skalerbarhed**: API kan skaleres uafhængigt
- **Multi-client Support**: Andre klienter kan bruge samme API
- **Deployment Flexibility**: Komponenter kan deployes separat
- **Team Specialization**: UI og backend teams kan arbejde parallelt

---

## Opgave 4: Web-app med Blazor

**Vi skal have lavet en web-app (brug gerne Blazor) til søgning, som anvender det API som blev lavet i opgave 3.**

### Blazor Server App Arkitektur:

#### Hovedkomponenter:

**1. Search Page Component**
```razor
@page "/search"
<SearchComponent />
```

**2. Search Component**
- Input felt til søge-queries
- Checkboxes for search options (case sensitive, pattern matching)
- Results display area
- Paging controls

**3. Services Integration**
```csharp
@inject ISearchService SearchService
```

#### Implementering Struktur:
```
BlazorSearchApp/
├── Program.cs
├── Pages/
│   ├── Index.razor         (Landing page)
│   └── Search.razor        (Main search page)
├── Components/
│   ├── SearchBox.razor     (Search input component)
│   ├── SearchResults.razor (Results display)
│   └── SearchOptions.razor (Configuration toggles)
├── Services/
│   ├── ISearchService.cs   (Interface)
│   └── SearchService.cs    (HTTP client til API)
├── Models/
│   ├── SearchRequest.cs    (Request DTOs)
│   └── SearchResult.cs     (Response DTOs)
└── wwwroot/
    ├── css/                (Styling)
    └── js/                 (Client-side scripts)
```

#### Key Features:

**Real-time Search:**
- Blazor Server's SignalR connection for responsive UI
- Debounced input for performance
- Loading indicators under søgning

**Search Options:**
- Toggle switches for case sensitivity
- Pattern matching enable/disable
- Result limit configuration
- Compact/detailed view toggle

**Results Display:**
- Paginated results
- Highlighting af search terms
- Document metadata (title, date, score)
- Responsive design for mobile/desktop

#### API Integration:
```csharp
public class SearchService : ISearchService
{
    private readonly HttpClient _httpClient;
    
    public async Task<SearchResponse> SearchAsync(SearchRequest request)
    {
        // HTTP call til Search API fra opgave 3
        var response = await _httpClient.PostAsJsonAsync("/api/search", request);
        return await response.Content.ReadFromJsonAsync<SearchResponse>();
    }
}
```

#### Fordele ved Blazor Web App:
- **Responsive UI**: Moderne web interface
- **Real-time Updates**: SignalR for live updates
- **Component Reusability**: Genbrugelige UI komponenter
- **Type Safety**: Shared DTOs mellem API og client
- **SEO Friendly**: Server-side rendering
- **Cross Platform**: Virker på alle browsere/enheder

### Integration Flow:
1. **User Input** → Blazor Component
2. **Search Request** → SearchService (HTTP client)
3. **API Call** → Search API (fra opgave 3)
4. **Database Query** → SearchLogic i API
5. **Results** → JSON response tilbage gennem stack
6. **UI Update** → Blazor re-renders results

Denne arkitektur demonstrerer fuld Y-akse skalering: UI lag (Blazor), API lag (Search API), og data lag (Database), hver med deres specifikke ansvar og skaleringsmuligheder.